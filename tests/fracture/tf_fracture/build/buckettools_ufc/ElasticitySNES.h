// This code conforms with the UFC specification version 1.5.0
// and was automatically generated by FFC version 1.5.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   cache_dir:                      ''
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   True
//   format:                         'dolfin'
//   log_level:                      20
//   log_prefix:                     ''
//   optimize:                       True
//   output_dir:                     '.'
//   precision:                      15
//   quadrature_degree:              'auto'
//   quadrature_rule:                'default'
//   representation:                 'quadrature'
//   restrict_keyword:               ''
//   split:                          True

#ifndef __ELASTICITYSNES_H
#define __ELASTICITYSNES_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class elasticitysnes_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  elasticitysnes_finite_element_0();

  /// Destructor
  virtual ~elasticitysnes_finite_element_0();

  /// Return a string identifying the finite element
  virtual const char* signature() const;

  /// Return the cell shape
  virtual ufc::shape cell_shape() const;

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const;

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const;

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const;

  /// Return the rank of the value space
  virtual std::size_t value_rank() const;

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const;

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation);

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation);

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation);

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation);

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const;

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const;

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const;

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const;

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const;

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const;

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const;

  /// Create a new class instance
  virtual ufc::finite_element* create() const;

};

/// This class defines the interface for a finite element.

class elasticitysnes_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  elasticitysnes_finite_element_1();

  /// Destructor
  virtual ~elasticitysnes_finite_element_1();

  /// Return a string identifying the finite element
  virtual const char* signature() const;

  /// Return the cell shape
  virtual ufc::shape cell_shape() const;

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const;

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const;

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const;

  /// Return the rank of the value space
  virtual std::size_t value_rank() const;

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const;

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation);

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation);

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation);

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation);

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const;

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const;

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const;

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const;

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const;

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const;

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const;

  /// Create a new class instance
  virtual ufc::finite_element* create() const;

};

/// This class defines the interface for a finite element.

class elasticitysnes_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  elasticitysnes_finite_element_2();

  /// Destructor
  virtual ~elasticitysnes_finite_element_2();

  /// Return a string identifying the finite element
  virtual const char* signature() const;

  /// Return the cell shape
  virtual ufc::shape cell_shape() const;

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const;

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const;

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const;

  /// Return the rank of the value space
  virtual std::size_t value_rank() const;

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const;

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation);

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation);

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation);

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation);

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const;

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const;

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const;

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const;

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const;

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const;

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const;

  /// Create a new class instance
  virtual ufc::finite_element* create() const;

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class elasticitysnes_dofmap_0: public ufc::dofmap
{
public:

  /// Constructor
  elasticitysnes_dofmap_0();

  /// Destructor
  virtual ~elasticitysnes_dofmap_0();

  /// Return a string identifying the dofmap
  virtual const char* signature() const;

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const;

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const;

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const;

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const;

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const;

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const;

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const;

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const;

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const;

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const;

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* coordinates,
                                    const double* vertex_coordinates) const;

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const;

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const;

  /// Create a new class instance
  virtual ufc::dofmap* create() const;

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class elasticitysnes_dofmap_1: public ufc::dofmap
{
public:

  /// Constructor
  elasticitysnes_dofmap_1();

  /// Destructor
  virtual ~elasticitysnes_dofmap_1();

  /// Return a string identifying the dofmap
  virtual const char* signature() const;

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const;

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const;

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const;

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const;

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const;

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const;

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const;

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const;

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const;

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const;

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* coordinates,
                                    const double* vertex_coordinates) const;

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const;

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const;

  /// Create a new class instance
  virtual ufc::dofmap* create() const;

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class elasticitysnes_dofmap_2: public ufc::dofmap
{
public:

  /// Constructor
  elasticitysnes_dofmap_2();

  /// Destructor
  virtual ~elasticitysnes_dofmap_2();

  /// Return a string identifying the dofmap
  virtual const char* signature() const;

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const;

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const;

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const;

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const;

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const;

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const;

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const;

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const;

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const;

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const;

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double* coordinates,
                                    const double* vertex_coordinates) const;

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const;

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const;

  /// Create a new class instance
  virtual ufc::dofmap* create() const;

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class elasticitysnes_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  elasticitysnes_cell_integral_0_otherwise();

  /// Destructor
  virtual ~elasticitysnes_cell_integral_0_otherwise();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const;

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class elasticitysnes_exterior_facet_integral_0_3: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  elasticitysnes_exterior_facet_integral_0_3();

  /// Destructor
  virtual ~elasticitysnes_exterior_facet_integral_0_3();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const;

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class elasticitysnes_exterior_facet_integral_0_4: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  elasticitysnes_exterior_facet_integral_0_4();

  /// Destructor
  virtual ~elasticitysnes_exterior_facet_integral_0_4();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const;

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class elasticitysnes_interior_facet_integral_0_otherwise: public ufc::interior_facet_integral
{
public:

  /// Constructor
  elasticitysnes_interior_facet_integral_0_otherwise();

  /// Destructor
  virtual ~elasticitysnes_interior_facet_integral_0_otherwise();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates_0,
                               const double*  vertex_coordinates_1,
                               std::size_t facet_0,
                               std::size_t facet_1,
                               int cell_orientation_0,
                               int cell_orientation_1) const;

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class elasticitysnes_cell_integral_1_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  elasticitysnes_cell_integral_1_otherwise();

  /// Destructor
  virtual ~elasticitysnes_cell_integral_1_otherwise();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const;

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class elasticitysnes_exterior_facet_integral_1_3: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  elasticitysnes_exterior_facet_integral_1_3();

  /// Destructor
  virtual ~elasticitysnes_exterior_facet_integral_1_3();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const;

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class elasticitysnes_exterior_facet_integral_1_4: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  elasticitysnes_exterior_facet_integral_1_4();

  /// Destructor
  virtual ~elasticitysnes_exterior_facet_integral_1_4();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const;

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class elasticitysnes_interior_facet_integral_1_otherwise: public ufc::interior_facet_integral
{
public:

  /// Constructor
  elasticitysnes_interior_facet_integral_1_otherwise();

  /// Destructor
  virtual ~elasticitysnes_interior_facet_integral_1_otherwise();

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const;

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates_0,
                               const double*  vertex_coordinates_1,
                               std::size_t facet_0,
                               std::size_t facet_1,
                               int cell_orientation_0,
                               int cell_orientation_1) const;

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class elasticitysnes_form_0: public ufc::form
{
public:

  /// Constructor
  elasticitysnes_form_0();

  /// Destructor
  virtual ~elasticitysnes_form_0();

  /// Return a string identifying the form
  virtual const char* signature() const;

  /// Return original coefficient position for each coefficient (0 <= i < n)
  virtual std::size_t original_coefficient_position(std::size_t i) const;

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const;

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const;

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const;

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const;

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const;

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const;

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const;

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const;

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const;

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const;

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const;

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const;

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const;

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const;

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const;

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const;

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const;

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const;

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const;

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const;

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const;

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const;

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const;

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const;
};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class elasticitysnes_form_1: public ufc::form
{
public:

  /// Constructor
  elasticitysnes_form_1();

  /// Destructor
  virtual ~elasticitysnes_form_1();

  /// Return a string identifying the form
  virtual const char* signature() const;

  /// Return original coefficient position for each coefficient (0 <= i < n)
  virtual std::size_t original_coefficient_position(std::size_t i) const;

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const;

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const;

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const;

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const;

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const;

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const;

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const;

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const;

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const;

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const;

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const;

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const;

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const;

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const;

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const;

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const;

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const;

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const;

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const;

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const;

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const;

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const;

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const;

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const;
};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>

namespace ElasticitySNES
{

class CoefficientSpace_G: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_G(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_G(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_G(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_G(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_G(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_G(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class CoefficientSpace_Kon2G: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_Kon2G(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_Kon2G(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_Kon2G(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_Kon2G(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_Kon2G(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_Kon2G(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class CoefficientSpace_alphalambda: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_alphalambda(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_alphalambda(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_alphalambda(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_alphalambda(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_alphalambda(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_alphalambda(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class CoefficientSpace_s: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_s(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_s(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_s(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_s(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_s(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_s(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class CoefficientSpace_sigmac: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_sigmac(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_sigmac(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_sigmac(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_sigmac(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_sigmac(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_sigmac(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class CoefficientSpace_u0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_u0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_u0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_u0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_u0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_u0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_u0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class CoefficientSpace_u1: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_u1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_u1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_u1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_u1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_u1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_u1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_0()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class CoefficientSpace_us_i: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_us_i(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_us_i(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_us_i(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_us_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  CoefficientSpace_us_i(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_us_i(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class Form_F_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_F_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_F_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  Form_F_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_F_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  Form_F_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_F_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

typedef CoefficientSpace_us_i Form_F_FunctionSpace_1;

typedef CoefficientSpace_sigmac Form_F_FunctionSpace_2;

typedef CoefficientSpace_alphalambda Form_F_FunctionSpace_3;

typedef CoefficientSpace_G Form_F_FunctionSpace_4;

typedef CoefficientSpace_Kon2G Form_F_FunctionSpace_5;

typedef CoefficientSpace_u0 Form_F_FunctionSpace_6;

typedef CoefficientSpace_u1 Form_F_FunctionSpace_7;

typedef CoefficientSpace_s Form_F_FunctionSpace_8;

class Form_F: public dolfin::Form
{
public:

  // Constructor
  Form_F(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 8), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), u0(*this, 5), u1(*this, 6), s(*this, 7)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_0());
  }

  // Constructor
  Form_F(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& us_i, const dolfin::GenericFunction& sigmac, const dolfin::GenericFunction& alphalambda, const dolfin::GenericFunction& G, const dolfin::GenericFunction& Kon2G, const dolfin::GenericFunction& u0, const dolfin::GenericFunction& u1, const dolfin::GenericFunction& s):
    dolfin::Form(1, 8), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), u0(*this, 5), u1(*this, 6), s(*this, 7)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->us_i = us_i;
    this->sigmac = sigmac;
    this->alphalambda = alphalambda;
    this->G = G;
    this->Kon2G = Kon2G;
    this->u0 = u0;
    this->u1 = u1;
    this->s = s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_0());
  }

  // Constructor
  Form_F(const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> sigmac, std::shared_ptr<const dolfin::GenericFunction> alphalambda, std::shared_ptr<const dolfin::GenericFunction> G, std::shared_ptr<const dolfin::GenericFunction> Kon2G, std::shared_ptr<const dolfin::GenericFunction> u0, std::shared_ptr<const dolfin::GenericFunction> u1, std::shared_ptr<const dolfin::GenericFunction> s):
    dolfin::Form(1, 8), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), u0(*this, 5), u1(*this, 6), s(*this, 7)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->us_i = *us_i;
    this->sigmac = *sigmac;
    this->alphalambda = *alphalambda;
    this->G = *G;
    this->Kon2G = *Kon2G;
    this->u0 = *u0;
    this->u1 = *u1;
    this->s = *s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_0());
  }

  // Constructor
  Form_F(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 8), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), u0(*this, 5), u1(*this, 6), s(*this, 7)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_0());
  }

  // Constructor
  Form_F(std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& us_i, const dolfin::GenericFunction& sigmac, const dolfin::GenericFunction& alphalambda, const dolfin::GenericFunction& G, const dolfin::GenericFunction& Kon2G, const dolfin::GenericFunction& u0, const dolfin::GenericFunction& u1, const dolfin::GenericFunction& s):
    dolfin::Form(1, 8), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), u0(*this, 5), u1(*this, 6), s(*this, 7)
  {
    _function_spaces[0] = V0;

    this->us_i = us_i;
    this->sigmac = sigmac;
    this->alphalambda = alphalambda;
    this->G = G;
    this->Kon2G = Kon2G;
    this->u0 = u0;
    this->u1 = u1;
    this->s = s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_0());
  }

  // Constructor
  Form_F(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> sigmac, std::shared_ptr<const dolfin::GenericFunction> alphalambda, std::shared_ptr<const dolfin::GenericFunction> G, std::shared_ptr<const dolfin::GenericFunction> Kon2G, std::shared_ptr<const dolfin::GenericFunction> u0, std::shared_ptr<const dolfin::GenericFunction> u1, std::shared_ptr<const dolfin::GenericFunction> s):
    dolfin::Form(1, 8), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), u0(*this, 5), u1(*this, 6), s(*this, 7)
  {
    _function_spaces[0] = V0;

    this->us_i = *us_i;
    this->sigmac = *sigmac;
    this->alphalambda = *alphalambda;
    this->G = *G;
    this->Kon2G = *Kon2G;
    this->u0 = *u0;
    this->u1 = *u1;
    this->s = *s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_0());
  }

  // Destructor
  ~Form_F()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_i")
      return 0;
    else if (name == "sigmac")
      return 1;
    else if (name == "alphalambda")
      return 2;
    else if (name == "G")
      return 3;
    else if (name == "Kon2G")
      return 4;
    else if (name == "u0")
      return 5;
    else if (name == "u1")
      return 6;
    else if (name == "s")
      return 7;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_i";
    case 1:
      return "sigmac";
    case 2:
      return "alphalambda";
    case 3:
      return "G";
    case 4:
      return "Kon2G";
    case 5:
      return "u0";
    case 6:
      return "u1";
    case 7:
      return "s";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_F_FunctionSpace_0 TestSpace;
  typedef Form_F_FunctionSpace_1 CoefficientSpace_us_i;
  typedef Form_F_FunctionSpace_2 CoefficientSpace_sigmac;
  typedef Form_F_FunctionSpace_3 CoefficientSpace_alphalambda;
  typedef Form_F_FunctionSpace_4 CoefficientSpace_G;
  typedef Form_F_FunctionSpace_5 CoefficientSpace_Kon2G;
  typedef Form_F_FunctionSpace_6 CoefficientSpace_u0;
  typedef Form_F_FunctionSpace_7 CoefficientSpace_u1;
  typedef Form_F_FunctionSpace_8 CoefficientSpace_s;

  // Coefficients
  dolfin::CoefficientAssigner us_i;
  dolfin::CoefficientAssigner sigmac;
  dolfin::CoefficientAssigner alphalambda;
  dolfin::CoefficientAssigner G;
  dolfin::CoefficientAssigner Kon2G;
  dolfin::CoefficientAssigner u0;
  dolfin::CoefficientAssigner u1;
  dolfin::CoefficientAssigner s;
};

class Form_J_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  Form_J_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

class Form_J_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 4 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  // Create standard function space (reference version)
  Form_J_FunctionSpace_1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain, 
                const dolfin::MeshFunction<std::size_t>& sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain),
                              dolfin::reference_to_no_delete_pointer(sub_domains),
                              master_domains, slave_domains)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain,
                std::shared_ptr<const dolfin::MeshFunction<std::size_t> > sub_domains,
                const std::vector<std::size_t>& master_domains, const std::vector<std::size_t>& slave_domains):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new elasticitysnes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new elasticitysnes_dofmap_2()), *mesh, 
                              constrained_domain, sub_domains, master_domains, slave_domains)))
  {
    // Do nothing
  }

};

typedef CoefficientSpace_us_i Form_J_FunctionSpace_2;

typedef CoefficientSpace_sigmac Form_J_FunctionSpace_3;

typedef CoefficientSpace_alphalambda Form_J_FunctionSpace_4;

typedef CoefficientSpace_G Form_J_FunctionSpace_5;

typedef CoefficientSpace_Kon2G Form_J_FunctionSpace_6;

typedef CoefficientSpace_s Form_J_FunctionSpace_7;

class Form_J: public dolfin::Form
{
public:

  // Constructor
  Form_J(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 6), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), s(*this, 5)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_1());
  }

  // Constructor
  Form_J(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& us_i, const dolfin::GenericFunction& sigmac, const dolfin::GenericFunction& alphalambda, const dolfin::GenericFunction& G, const dolfin::GenericFunction& Kon2G, const dolfin::GenericFunction& s):
    dolfin::Form(2, 6), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), s(*this, 5)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->us_i = us_i;
    this->sigmac = sigmac;
    this->alphalambda = alphalambda;
    this->G = G;
    this->Kon2G = Kon2G;
    this->s = s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_1());
  }

  // Constructor
  Form_J(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> sigmac, std::shared_ptr<const dolfin::GenericFunction> alphalambda, std::shared_ptr<const dolfin::GenericFunction> G, std::shared_ptr<const dolfin::GenericFunction> Kon2G, std::shared_ptr<const dolfin::GenericFunction> s):
    dolfin::Form(2, 6), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), s(*this, 5)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->us_i = *us_i;
    this->sigmac = *sigmac;
    this->alphalambda = *alphalambda;
    this->G = *G;
    this->Kon2G = *Kon2G;
    this->s = *s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_1());
  }

  // Constructor
  Form_J(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 6), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), s(*this, 5)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_1());
  }

  // Constructor
  Form_J(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& us_i, const dolfin::GenericFunction& sigmac, const dolfin::GenericFunction& alphalambda, const dolfin::GenericFunction& G, const dolfin::GenericFunction& Kon2G, const dolfin::GenericFunction& s):
    dolfin::Form(2, 6), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), s(*this, 5)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->us_i = us_i;
    this->sigmac = sigmac;
    this->alphalambda = alphalambda;
    this->G = G;
    this->Kon2G = Kon2G;
    this->s = s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_1());
  }

  // Constructor
  Form_J(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> us_i, std::shared_ptr<const dolfin::GenericFunction> sigmac, std::shared_ptr<const dolfin::GenericFunction> alphalambda, std::shared_ptr<const dolfin::GenericFunction> G, std::shared_ptr<const dolfin::GenericFunction> Kon2G, std::shared_ptr<const dolfin::GenericFunction> s):
    dolfin::Form(2, 6), us_i(*this, 0), sigmac(*this, 1), alphalambda(*this, 2), G(*this, 3), Kon2G(*this, 4), s(*this, 5)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->us_i = *us_i;
    this->sigmac = *sigmac;
    this->alphalambda = *alphalambda;
    this->G = *G;
    this->Kon2G = *Kon2G;
    this->s = *s;

    _ufc_form = std::shared_ptr<const ufc::form>(new elasticitysnes_form_1());
  }

  // Destructor
  ~Form_J()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "us_i")
      return 0;
    else if (name == "sigmac")
      return 1;
    else if (name == "alphalambda")
      return 2;
    else if (name == "G")
      return 3;
    else if (name == "Kon2G")
      return 4;
    else if (name == "s")
      return 5;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "us_i";
    case 1:
      return "sigmac";
    case 2:
      return "alphalambda";
    case 3:
      return "G";
    case 4:
      return "Kon2G";
    case 5:
      return "s";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_J_FunctionSpace_0 TestSpace;
  typedef Form_J_FunctionSpace_1 TrialSpace;
  typedef Form_J_FunctionSpace_2 CoefficientSpace_us_i;
  typedef Form_J_FunctionSpace_3 CoefficientSpace_sigmac;
  typedef Form_J_FunctionSpace_4 CoefficientSpace_alphalambda;
  typedef Form_J_FunctionSpace_5 CoefficientSpace_G;
  typedef Form_J_FunctionSpace_6 CoefficientSpace_Kon2G;
  typedef Form_J_FunctionSpace_7 CoefficientSpace_s;

  // Coefficients
  dolfin::CoefficientAssigner us_i;
  dolfin::CoefficientAssigner sigmac;
  dolfin::CoefficientAssigner alphalambda;
  dolfin::CoefficientAssigner G;
  dolfin::CoefficientAssigner Kon2G;
  dolfin::CoefficientAssigner s;
};

// Class typedefs
typedef Form_J BilinearForm;
typedef Form_J JacobianForm;
typedef Form_F LinearForm;
typedef Form_F ResidualForm;
typedef Form_F::TestSpace FunctionSpace;

}

#endif
